<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sorting Algorithms Information</title>
    <link rel="stylesheet" href="style.css">
    <script src="info.js"></script>
</head>
<body>
    <h1>Sorting Algorithms Information</h1>
    <div id="info-content">
        <ul id="algorithm-list">
            <!-- Selection Sort -->
            <li class="algorithm-item" data-algo="selection">
                <h2 class="accordion">Selection Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Selection sort is an in-place comparison sorting algorithm. It divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list.</p>
                    <p>In every iteration of the selection sort, the minimum element from the unsorted sublist is picked and moved to the sorted sublist.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <p>Best Case: O(n<sup>2</sup>)</p>
                        <p>Average Case: O(n<sup>2</sup>)</p>
                        <p>Worst Case: O(n<sup>2</sup>)</p>
                    </ul>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p><strong>Stable:</strong> No</p>
                    <p><strong>Markers:</strong> Orange highlights the current minimum, red indicates the element being compared, blue shows elements being swapped.</p>
                </div>
            </li>
            <!-- Insertion Sort -->
            <li class="algorithm-item" data-algo="insertion">
                <h2 class="accordion">Insertion Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Insertion sort builds the final sorted array one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.</p>
                    <p>Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <p>Best Case: O(n) when the array is already sorted</p>
                        <p>Average Case: O(n<sup>2</sup>)</p>
                        <p>Worst Case: O(n<sup>2</sup>) when the array is reverse sorted</p>
                    </ul>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p><strong>Stable:</strong> Yes</p>
                    <p><strong>Markers:</strong> Orange highlights the current key element, red indicates the element being compared.</p>
                </div>
            </li>
            <!-- Bubble Sort -->
            <li class="algorithm-item" data-algo="bubble">
                <h2 class="accordion">Bubble Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. This pass-through of the list is repeated until the list is sorted.</p>
                    <p>The algorithm gets its name from the way smaller elements "bubble" to the top of the list through swaps.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <p>Best Case: O(n) when the array is already sorted</p>
                        <p>Average Case: O(n<sup>2</sup>)</p>
                        <p>Worst Case: O(n<sup>2</sup>) when the array is reverse sorted</p>
                    </ul>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p><strong>Stable:</strong> Yes</p>
                    <p><strong>Markers:</strong> Red indicates elements being compared, blue shows elements being swapped.</p>
                </div>
            </li>
            <!-- Shell Sort -->
            <li class="algorithm-item" data-algo="shell">
                <h2 class="accordion">Shell Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Shell sort is an in-place comparison sort. It generalizes insertion sort by allowing the exchange of items that are far apart. The method starts by sorting pairs of elements far apart from each other, then progressively reducing the gap between elements to be compared.</p>
                    <p>The idea is that the array elements are arranged such that starting anywhere, taking every hth element produces a sorted list. Such a list is said to be h-sorted.</p>
                    <p><strong>Time Complexity:</strong> Depends on the gap sequence; typically between O(n log n<sup>2</sup>) and O(n<sup>3‚ÅÑ2</sup>).</p>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p><strong>Stable:</strong> No</p>
                    <p><strong>Markers:</strong> Orange highlights the current element being inserted, red indicates elements being compared.</p>
                </div>
            </li>
            <!-- Merge Sort -->
            <li class="algorithm-item" data-algo="merge">
                <h2 class="accordion">Merge Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Merge sort is a divide and conquer algorithm that was invented by John von Neumann in 1945. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves.</p>
                    <p>The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <p>Best Case: O(n log n)</p>
                        <p>Average Case: O(n log n)</p>
                        <p>Worst Case: O(n log n)</p>
                    </ul>
                    <p><strong>Space Complexity:</strong> O(n)</p>
                    <p><strong>Stable:</strong> Yes</p>
                    <p><strong>Markers:</strong> Orange indicates current elements being merged.</p>
                </div>
            </li>
            <!-- Quick Sort -->
            <li class="algorithm-item" data-algo="quick">
                <h2 class="accordion">Quick Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Quick sort is an efficient, in-place sorting algorithm that in practice is faster than merge sort and heap sort. However, it is not a stable sorting algorithm.</p>
                    <p>Quick sort works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <p>Best Case: O(n log n)</p>
                        <p>Average Case: O(n log n)</p>
                        <p>Worst Case: O(n<sup>2</sup>) when the smallest or largest element is always chosen as the pivot</p>
                    </ul>
                    <p><strong>Space Complexity:</strong> O(log n)</p>
                    <p><strong>Stable:</strong> No</p>
                    <p><strong>Markers:</strong> Purple highlights the pivot, red indicates elements being compared, blue shows elements being swapped.</p>
                </div>
            </li>
            <!-- Heap Sort -->
            <li class="algorithm-item" data-algo="heap">
                <h2 class="accordion">Heap Sort</h2>
                <div class="algo-info hidden">
                    <p><strong>Description:</strong> Heap sort is a comparison-based sorting technique based on a binary heap data structure. It is similar to selection sort where we first find the maximum element and place it at the end. We repeat the same process for the remaining elements.</p>
                    <p>Heap sort first builds a max heap from the input data, and then repeatedly extracts the maximum element from the heap and reconstructs the heap.</p>
                    <p><strong>Time Complexity:</strong></p>
                    <ul>
                        <p>Best Case: O(n log n)</p>
                        <p>Average Case: O(n log n)</p>
                        <p>Worst Case: O(n log n)</p>
                    </ul>
                    <p><strong>Space Complexity:</strong> O(1)</p>
                    <p><strong>Stable:</strong> No</p>
                    <p><strong>Markers:</strong> Blue shows elements being swapped during heapify and extraction.</p>
                </div>
            </li>
        </ul>
        <a href="index.html" id="back-btn">Back to Visualizer</a>
    </div>
</body>
</html>
